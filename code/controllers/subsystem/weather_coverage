/*
 * Weather Coverage Subsystem - It actually only handles init weather coverage and passes that info off to the chunking system
 * since that's more efficient. Chunking handles realtime weather coverage information.
 */

#define UNCOVERED FALSE
#define COVERED TRUE


SUBSYSTEM_DEF(weather_coverage)
	name = "Weather Coverage"
	init_order = SS_INIT_LATE
	flags = SS_BACKGROUND
	wait = 10

	var/list/exposed_turfs = list() // Temporary cache used for initial registration with the chunking system.

	//Referencing the weather_chunking system for the whole DM.
	var/datum/weather/chunking = new

/// Initialization Starts

//Registering signals, calling exposed turf calculations, and calling data pass to chunking.
/datum/controller/subsystem/weather_coverage/Initialize(timeofday)
	..()

	registerSignal(COMSIG_TURF_CREATED, PROC_REF(on_turf_created))
	registerSignal(COMSIG_TURF_DESTROYED, PROC_REF(on_turf_destroyed))

	initialize_weather_coverage()
	finalize_exposed_turf_registration()

/datum/controller/subsystem/weather_coverage/proc/initialize_weather_coverage()
	var/maxx = world.maxx
	var/maxy = world.maxy
	var/maxz = world.maxz

	for (var/x = 1 to maxx)
		for (var/y = 1 to maxy)

			var/found_exposed = FALSE

			// Scan from top to bottom in each (x, y) column.
			for (var/z = maxz, z > 1, z--)

				var/turf/T = locate(x, y, z)
				if (!T)
					continue

				if (!T.blocks_weather)
					// This turf doesn't block weather—mark the one below as exposed.
					weather_update_below(T)
					found_exposed = TRUE
					break

				// This turf blocks weather—everything below is covered.
				break

			// If there was no turf at the top or all were null, mark the one below maxz as exposed.
			if(!found_exposed)
				var/turf/top = locate(x, y, maxz)
				weather_update_below(top)

// Helper for scanning below during Init calculations
/datum/controller/subsystem/weather_coverage/proc/weather_update_below(var/turf/T)
	if(!T)
		return

	var/turf/below = locate(T.x, T.y, T.z - 1)
	if(below && below.cover_cache != UNCOVERED)
		set_exposed(below, TRUE)

/// Initialization Ends


/// Utilities for Turf Creation/Destruction
/datum/controller/subsystem/weather_coverage/proc/on_turf_created(turf/T)
	if(!T || !T.z) return

	var/turf/below = locate(T.x, T.y, T.z - 1)

	if(!below)
		return

	if(T.blocks_weather)
		// Turf now blocks weather; below is no longer exposed
		set_exposed(below, FALSE) //Set_exposed marks the turf as covered.

/datum/controller/subsystem/weather_coverage/proc/on_turf_destroyed(turf/T)
	if(!T || !T.z)
		return

	if(!T.blocks_weather)
		// Turf that was destroyed didn't block weather, so no point in checking, since fundementally nothing should change.
		return

	//Check the turf below the destroyed turf
	var/turf/below = locate(T.x, T.y, T.z - 1)
	if(below) //If the turf below exists, go through the next step of validations
		update_turf_exposure(below)

/datum/controller/subsystem/weather_coverage/proc/update_turf_exposure(turf/T)
	if(!T)
		return

	// Turf that blocked weather is now gone; below might be exposed
	var/turf/above = locate(T.x, T.y, T.z + 1)
    var/is_exposed = (!above || !above.blocks_weather);

    set_exposed(T, is_exposed);

//Sets the turf as covered or uncovered, and flags it for a weather update.
/datum/controller/subsystem/weather_coverage/proc/set_exposed(turf/T, is_exposed)
	if(!T)
		return

	if(is_exposed)
        if(T.cover_cache != UNCOVERED)
            T.cover_cache = UNCOVERED
            exposed_turfs |= T
            weather_chunking.register_exposed_turf(T)
            T.needs_weather_update = TRUE
    else
        if(T.cover_cache != COVERED)
            T.cover_cache = COVERED
            exposed_turfs -= T
            weather_chunking.unregister_exposed_turf(T)
            T.needs_weather_update = TRUE



/datum/controller/subsystem/weather_coverage/proc/finalize_exposed_turf_registration()
	if(!weather_chunking)
		return
	for(var/turf/T in exposed_turfs)
		weather_chunking.register_exposed_turf(T)
